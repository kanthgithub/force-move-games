import BN from 'bn.js';
import { Channel } from '../channel';
import { State } from '../state';
import expectRevert from './helpers/expect-revert';
import { CountingGame } from '../test-game/counting-game';
import { sign } from '../utils';

import Web3 from 'web3';
const web3 = new Web3('http://localhost:8545');
import { ethers, ContractFactory, Wallet } from 'ethers';

// @ts-ignore
import StateArtifact from "../../build/contracts/State.json";

describe('State', () => {
  const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
  const privateKey = "0xf2f48ee19680706196e2e339e5da3491186e0c4c5030670656b0e0164837257d";
  const wallet = new Wallet(privateKey, provider);

  let stateLib;
  const channelNonce = 12;
  const turnNum = 15;
  // private keys are from the accounts generated by `ganache-cli -d`
  const channelType = web3.eth.accounts.privateKeyToAccount('4f3edf983ac636a65a842ce7c78d9aa706d3b113bce9c46f30d7d21715b23b1d').address; // just get a valid address
  const participantA = web3.eth.accounts.privateKeyToAccount('6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1');
  const participantB = web3.eth.accounts.privateKeyToAccount('6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c');
  const participants = [participantA.address, participantB.address];
  const resolution = [new BN(5), new BN(4)];
  const channel = new Channel(channelType, channelNonce, participants);
  const stateType = State.StateType.Game;
  const state = new State({
    channel, stateType, turnNum, resolution, stateCount: 0,
  });
  const statePacket = state.toHex();

  beforeEach(async () => {
    const networkId = (await provider.getNetwork()).chainId;
    const factory = ContractFactory.fromSolidity(StateArtifact, wallet);

    stateLib = await factory.attach(StateArtifact.networks[networkId].address);
  });

  it("extracts the channelType", async () => {
    const result = await stateLib.channelType(statePacket);
    expect(channelType).toEqual(result);
  });

  it("extracts the channelNonce", async () => {
    const result = await stateLib.channelNonce(statePacket);
    expect(channelNonce).toEqual(result.toNumber());
  });

  it("extracts the turnNum", async () => {
    const result = await stateLib.turnNum(statePacket);
    expect(turnNum).toEqual(result.toNumber());
  });

  it("extracts the number of participants", async () => {
    const n = await stateLib.numberOfParticipants(statePacket);
    expect(n.toNumber()).toEqual(2);
  });

  it("extracts the participants", async () => {
    const result = await stateLib.participants(statePacket);
    expect(participants).toEqual(result);
  });

  it("extracts the resolution", async () => {
    const result = await stateLib.resolution(statePacket);
    expect(resolution[0].toNumber()).toEqual(result[0].toNumber());
    expect(resolution[1].toNumber()).toEqual(result[1].toNumber());
  });

  it("identifies the mover based on the turnNum", async () => {
    const mover = await stateLib.mover(statePacket);
    // our state nonce is 15, which is odd, so it should be participant[1]
    expect(mover).toEqual(participants[1]);
  });

  it("identifies the indexOfMover based on the turnNum", async () => {
    const index = await stateLib.indexOfMover(statePacket);
    // our state nonce is 15, which is odd, so it should be participant 1
    expect(index.toNumber()).toEqual(1);
  });

  it("can calculate the channelId", async () => {
    const chainId = await stateLib.channelId(statePacket);
    const localId = channel.id;

    expect(chainId).toEqual(localId);
  });

  it("can check if a state is signed", async () => {
    // needs to be signed by 1 as it's their move
    const { r, s, v } = sign(
      state.toHex(),
      participantB.privateKey,
    );

    expect(await stateLib.requireSignature(statePacket, v, r, s)).toBeTruthy();
  });

  it.skip("will revert if the wrong party signed", async () => {
    // needs to be signed by 1 as it's their move
    const { v, r, s } = sign(state.toHex(), participantA.privateKey);
    expectRevert(stateLib.requireSignature(statePacket, v, r, s));
  });

  it("can check if the state is fully signed", async() => {
    const { r: r0, s: s0, v: v0 } = sign(state.toHex(), participantA.privateKey);
    const { r: r1, s: s1, v: v1 } = sign(state.toHex(), participantB.privateKey);

    expect(await stateLib.requireFullySigned(statePacket, [v0, v1], [r0, r1], [s0, s1])).toBeTruthy();
  });

  it("calculates the offset for the gameState", async() => {
    const offset = await stateLib.gameStateOffset(statePacket);

    // should be 128 + 2 * 64 + 96 = 352
    // TODO find better way to test this
    expect(offset.toNumber()).toEqual(352);
  });

  it.skip("can test if the gameAttributes are equal", async() => {
    const state1 = CountingGame.preFundSetupState({channel, resolution, turnNum, gameCounter: 0 });
    const state2 = CountingGame.preFundSetupState({channel, resolution, turnNum, gameCounter: 1 });

    await expectRevert(stateLib.gameAttributesEqual(state1.toHex(), state2.toHex()));
  });


});
