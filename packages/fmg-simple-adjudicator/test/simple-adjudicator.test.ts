import {
  utils,
  web3
} from 'web3';
import {
  Channel,
  State,
  expectRevert,
  increaseTime,
  DURATION,
  CountingGame,
  sign,
  SolidityType,
  StateLibArtifact,
  CountingStateArtifact,
  CountingGameArtifact,
} from 'fmg-core';
import BN from 'bn.js';
import { assert } from 'chai';
import { linker } from 'solc/linker'
import { ethers, ContractFactory, Wallet } from 'ethers';

// @ts-ignore
import SimpleAdjudicatorArtifact from "../build/contracts/SimpleAdjudicator.json";

import * as truffleAssert from 'truffle-assertions';

const A_IDX = 1;
const B_IDX = 2;
const aBal = Number(utils.toWei('6', "wei"));
const bBal = Number(utils.toWei('4', "wei"));
const resolution = [aBal, bBal];
const differentResolution = [bBal, aBal];

const ACCOUNTS = [
  '0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1',
  '0xffcf8fdee72ac11b5c542428b35eef5769c409f0',
  '0x22d491bde2303f2f43325b2108d26f1eaba1e32b',
  '0xe11ba2b4d45eaed5996cd0823791e0c93114882d',
  '0xd03ea8624c8c5987235048901fb614fdca89b117',
  '0x95ced938f7991cd0dfcb48f0a06a40fa1af46ebc',
  '0x3e5e9111ae8eb78fe1cc3bb8915d5d461f3ef9a9',
  '0x28a8746e75304c0780e011bed21c72cd78cd535e',
  '0xaca94ef8bd5ffee41947b4585a84bda5a3d3da6e',
  '0x1df62f291b2e969fb0849d99d9ce41e2f137006e',
]

describe('foo', () => {
  it("works", () => {
    expect(1).toBe(1);
  })
})

describe('SimpleAdjudicator', async () => {
  it('does something', () => {
    expect(1).toBe(1);
  })

  const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");
  const privateKey = '0x' + '1'.repeat(64);
  const wallet = new Wallet(privateKey, provider);
  const networkId = (await provider.getNetwork()).chainId;

  let simpleAdj;
  let channel;
  let state0, state1, state2, state3, state1alt, state2alt;

  // private keys are from the accounts generated by `ganache-cli -d`
  const alice = new ethers.Wallet('6cbed15c793ce57650b9877cf6fa156fbef513c4e6134f022a85b1ffdd59b2a1');
  const bob = new ethers.Wallet('6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c');
  let aliceDestination, bobDestination;

  const challenger = bob;
  const challengee = alice;

  let aliceState, aliceBal, r0, v0, s0;
  let bobState, bobBal, r1, v1, s1;
  let aliceEthAccount, bobEthAccount;

  beforeEach(async () => {
    CountingStateArtifact.bytecode = (linker.linkBytecode(CountingStateArtifact.bytecode, { "State": StateLibArtifact.networks[networkId].address }));

    CountingGameArtifact.bytecode = (linker.linkBytecode(CountingGameArtifact.bytecode, { "CountingState": CountingStateArtifact.networks[networkId].address}));
    const countingGameContract = await ContractFactory.fromSolidity(CountingGameArtifact, wallet).attach(CountingGameArtifact.networks[networkId].address);

    channel = new Channel(
      countingGameContract.address.toLowerCase(),
      0,
      [alice.address.toLowerCase(), bob.address.toLowerCase()]
    );

    state0 = CountingGame.gameState({
      channel,
      resolution,
      turnNum: 6,
      gameCounter: 1
    });
    state1 = CountingGame.gameState({
      channel,
      resolution,
      turnNum: 7,
      gameCounter: 2
    });
    state2 = CountingGame.gameState({
      channel,
      resolution,
      turnNum: 8,
      gameCounter: 3
    });
    state3 = CountingGame.gameState({
      channel,
      resolution,
      turnNum: 9,
      gameCounter: 4
    });

    state1alt = CountingGame.gameState({
      channel,
      resolution: differentResolution,
      turnNum: 7,
      gameCounter: 2
    });
    state2alt = CountingGame.gameState({
      channel,
      resolution: differentResolution,
      turnNum: 8,
      gameCounter: 3
    });

    simpleAdj = await ContractFactory.fromSolidity(SimpleAdjudicatorArtifact, wallet).deploy(channel.id, 5);
  });

  it("forceMove emits ForceMove", async () => {
    expect(1).toBe(0);
    let agreedState = state0;
    let challengeState = state1;
    let responseState = state2;

    let {
      r: r0,
      s: s0,
      v: v0
    } = sign(agreedState.toHex(), challengee.privateKey);
    let {
      r: r1,
      s: s1,
      v: v1
    } = sign(challengeState.toHex(), challenger.privateKey);

    expect(await simpleAdj.currentChallengePresent()).toBe(false);

    let tx = await simpleAdj.forceMove(
      agreedState.toHex(), challengeState.toHex(), [v0, v1], [r0, r1], [s0, s1]
    );

    truffleAssert.eventEmitted(tx, "ChallengeCreated", (event) => {
      return event.channelId === channel.id && event.state === challengeState.toHex();
    })

    // Have to cancel the challenge as to not muck up further tests...
    const {
      r: r2,
      s: s2,
      v: v2
    } = sign(responseState.toHex(), challengee.privateKey);
    await simpleAdj.respondWithMove(responseState.toHex(), v2, r2, s2);
  });

  it("forceMove -> respondWithMove", async () => {
    let agreedState = state0;
    let challengeState = state1;
    let responseState = state2;

    const {
      r: r0,
      s: s0,
      v: v0
    } = sign(agreedState.toHex(), challengee.privateKey)
    const {
      r: r1,
      s: s1,
      v: v1
    } = sign(challengeState.toHex(), challenger.privateKey);

    assert.equal(await simpleAdj.currentChallengePresent(), false);

    await simpleAdj.forceMove(
      agreedState.toHex(), challengeState.toHex(), [v0, v1], [r0, r1], [s0, s1]
    );
    assert.equal(await simpleAdj.currentChallengePresent(), true);

    let {
      r: r2,
      s: s2,
      v: v2
    } = sign(responseState.toHex(), challengee.privateKey);
    let tx = await simpleAdj.respondWithMove(responseState.toHex(), v2, r2, s2);

    assert.equal(await simpleAdj.currentChallengePresent(), false);
    truffleAssert.eventEmitted(tx, "RespondedWithMove", (event) => {
      return event.response === responseState.toHex();
    })
  });

  it("forceMove -> refute", async () => {
    let agreedState = state0;
    let challengeState = state1;
    let refutationState = state3;

    let {
      r: r0,
      s: s0,
      v: v0
    } = sign(agreedState.toHex(), challengee.privateKey);
    let {
      r: r1,
      s: s1,
      v: v1
    } = sign(challengeState.toHex(), challenger.privateKey);

    assert.equal(await simpleAdj.currentChallengePresent(), false, "challenge exists at start of game");

    await simpleAdj.forceMove(agreedState.toHex(), challengeState.toHex(), [v0, v1], [r0, r1], [s0, s1]);
    assert.equal(await simpleAdj.currentChallengePresent(), true, "challenge wasn't created");

    // refute
    let {
      r: r2,
      s: s2,
      v: v2
    } = sign(refutationState.toHex(), challenger.privateKey);

    let tx = await simpleAdj.refute(refutationState.toHex(), v2, r2, s2);
    assert.equal(await simpleAdj.currentChallengePresent(), false, "challenge wasn't canceled");
    truffleAssert.eventEmitted(tx, "Refuted", (event) => {
      return event.refutation === refutationState.toHex();
    })
  });

  it("forceMove -> alternativeRespondWithMove", async () => {
    let agreedState = state0;
    let challengeState = state1;
    let alternativeState = state1alt;
    let responseState = state2alt;

    let {
      r: r0,
      s: s0,
      v: v0
    } = sign(agreedState.toHex(), challengee.privateKey);
    let {
      r: r1,
      s: s1,
      v: v1
    } = sign(challengeState.toHex(), challenger.privateKey);

    assert.equal(await simpleAdj.currentChallengePresent(), false, "challenge exists at start of game");

    await simpleAdj.forceMove(agreedState.toHex(), challengeState.toHex(), [v0, v1], [r0, r1], [s0, s1]);
    assert.equal(await simpleAdj.currentChallengePresent(), true, "challenge not created");

    let {
      r: r2,
      s: s2,
      v: v2
    } = sign(alternativeState.toHex(), challenger.privateKey);
    let {
      r: r3,
      s: s3,
      v: v3
    } = sign(responseState.toHex(), challengee.privateKey);

    let tx = await simpleAdj.alternativeRespondWithMove(
      alternativeState.toHex(),
      responseState.toHex(),
      [v2, v3], [r2, r3], [s2, s3]
    );

    assert.equal(await simpleAdj.currentChallengePresent(), false, "challenge not cancelled");
    truffleAssert.eventEmitted(tx, "RespondedWithAlternativeMove", (event) => {
      return event.alternativeResponse === responseState.toHex();
    })
  });

  it("can only be concluded once", async () => {
    aliceState = state0;
    bobState = state1;
    aliceState.stateType = State.StateType.Conclude;
    bobState.stateType = State.StateType.Conclude;
    const {
      r: r0,
      s: s0,
      v: v0
    } = sign(aliceState.toHex(), alice.privateKey);
    const {
      r: r1,
      s: s1,
      v: v1
    } = sign(bobState.toHex(), bob.privateKey);
    await simpleAdj.conclude(aliceState.toHex(), bobState.toHex(), [v0, v1], [r0, r1], [s0, s1]);
    expectRevert(
      simpleAdj.conclude(aliceState.toHex(), bobState.toHex(), [v0, v1], [r0, r1], [s0, s1])
    );
  });

  describe("withdrawals", () => {
    let aliceStart, bobStart;
    async function withdrawHelper(account, destination) {
      const {
        v,
        r,
        s
      } = sign(
        [{
            type: SolidityType.address,
            value: account.address
          },
          {
            type: SolidityType.address,
            value: destination
          },
          {
            type: SolidityType.bytes32,
            value: channel.id
          },
        ],
        account.privateKey
      );

      await simpleAdj.withdraw(
        account.address,
        destination,
        channel.id,
        v, r, s,
      );
    }

    beforeEach(async () => {
      aliceState = state0;
      bobState = state1;

      aliceBal = aBal;
      bobBal = bBal;

      aliceEthAccount = ACCOUNTS[A_IDX];
      bobEthAccount = ACCOUNTS[B_IDX];

      aliceStart = await Number(await web3.eth.getBalance(aliceEthAccount));
      bobStart = await Number(await web3.eth.getBalance(bobEthAccount));

      // Generate random destination addresses for more deterministic tests.
      // How ironic.
      aliceDestination = web3.eth.accounts.create().address.toLowerCase();
      bobDestination = web3.eth.accounts.create().address.toLowerCase();

      // simpleAdj = await SimpleAdjudicator.new(channel.id, 5);
      simpleAdj = await ContractFactory.fromSolidity(SimpleAdjudicatorArtifact, wallet).deploy(channel.id, 5);
    });

    it("conclude -> withdraw", async () => {
      await web3.eth.sendTransaction({
        from: aliceEthAccount,
        to: simpleAdj.address,
        value: aliceBal,
        gasPrice: 0
      });

      await web3.eth.sendTransaction({
        from: bobEthAccount,
        to: simpleAdj.address,
        value: bobBal,
        gasPrice: 0
      });

      assert.equal(
        await web3.eth.getBalance(simpleAdj.address),
        aliceBal + bobBal,
        "Funds were not deposited in the SimpleAdjudicator"
      );
      assert.equal(
        Number(await web3.eth.getBalance(bobEthAccount)),
        bobStart - bobBal,
        "Funds were not deposited from bob"
      );
      assert.equal(
        Number(await web3.eth.getBalance(aliceEthAccount)),
        aliceStart - aliceBal,
        "Funds were not deposited from alice"
      );

      // create a valid conclusion proof
      aliceState.stateType = State.StateType.Conclude;
      bobState.stateType = State.StateType.Conclude;

      const {
        r: r0,
        s: s0,
        v: v0
      } = sign(aliceState.toHex(), alice.privateKey);
      const {
        r: r1,
        s: s1,
        v: v1
      } = sign(bobState.toHex(), bob.privateKey);

      // pass the conclusion proof
      await simpleAdj.conclude(aliceState.toHex(), bobState.toHex(), [v0, v1], [r0, r1], [s0, s1]);

      await withdrawHelper(bob, bobDestination);

      assert.equal(
        Number(await web3.eth.getBalance(bobDestination)),
        bBal,
        "Bob's balance resolved incorrectly after his withdrawal."
      );

      assert.equal(
        Number(await web3.eth.getBalance(aliceDestination)),
        0,
        "Alice's balance resolved incorrectly before her withdrawal."
      );

      await withdrawHelper(alice, aliceDestination);
      assert.equal(
        Number(await web3.eth.getBalance(aliceDestination)),
        aliceBal,
        "Alice's balance resolved incorrectly after her withdrawal."
      );

      assert.equal(
        await web3.eth.getBalance(simpleAdj.address),
        0,
        "SimpleAdjudicator wasn't emptied"
      );

      await withdrawHelper(bob, bobDestination);

      assert.equal(
        Number(await web3.eth.getBalance(bobDestination)),
        bBal,
        "Bob withdrew multiple times."
      );
    });

    it("forceMove -> timeout -> withdraw", async () => {
      // fund the contract
      await web3.eth.sendTransaction({
        from: aliceEthAccount, // challengee
        to: simpleAdj.address,
        value: aliceBal,
        gasPrice: 0
      });

      await web3.eth.sendTransaction({
        from: bobEthAccount, // challenger
        to: simpleAdj.address,
        value: bobBal,
        gasPrice: 0
      });

      assert.equal(
        await web3.eth.getBalance(simpleAdj.address),
        aliceBal + bobBal,
        "Funds were not deposited in the SimpleAdjudicator"
      );
      assert.equal(
        Number(await web3.eth.getBalance(bobEthAccount)),
        bobStart - bobBal,
        "Funds were not deposited from bob"
      );
      assert.equal(
        Number(await web3.eth.getBalance(aliceEthAccount)),
        aliceStart - aliceBal,
        "Funds were not deposited from alice"
      );


      const {
        r: r0,
        s: s0,
        v: v0
      } = sign(aliceState.toHex(), alice.privateKey);
      const {
        r: r1,
        s: s1,
        v: v1
      } = sign(bobState.toHex(), bob.privateKey)

      await simpleAdj.forceMove(aliceState.toHex(), bobState.toHex(), [v0, v1], [r0, r1], [s0, s1]);
      await increaseTime(DURATION.days(2));

      await withdrawHelper(alice, aliceDestination);
      await withdrawHelper(bob, bobDestination);

      assert.equal(
        await web3.eth.getBalance(simpleAdj.address),
        0,
        "SimpleAdjudicator wasn't emptied"
      );
      assert.equal(
        Number(await web3.eth.getBalance(bobDestination)),
        bobBal,
        "Resolved Bob's balances incorrectly."
      );
      assert.equal(
        Number(await web3.eth.getBalance(aliceDestination)),
        aliceBal,
        "Resolved Alice's balances incorrectly."
      );
    });

    it("allows proper withdrawals in an insufficiently funded game", async () => {
      await web3.eth.sendTransaction({
        from: bobEthAccount,
        to: simpleAdj.address,
        value: bobBal,
        gasPrice: 0
      });

      assert.equal(
        Number(await web3.eth.getBalance(simpleAdj.address)),
        bobBal,
        "Funds were not deposited in the SimpleAdjudicator"
      );
      assert.equal(
        Number(await web3.eth.getBalance(bobEthAccount)),
        bobStart - bobBal,
        "Funds were not deposited from bob"
      );
      assert.equal(
        Number(await web3.eth.getBalance(aliceEthAccount)),
        aliceStart,
        "Funds were deposited from alice"
      );

      aliceState.stateType = State.StateType.Conclude;
      bobState.stateType = State.StateType.Conclude;

      const {
        r: r0,
        s: s0,
        v: v0
      } = sign(aliceState.toHex(), alice.privateKey)
      const {
        r: r1,
        s: s1,
        v: v1
      } = sign(bobState.toHex(), bob.privateKey);

      await simpleAdj.conclude(aliceState.toHex(), bobState.toHex(), [v0, v1], [r0, r1], [s0, s1]);
      await withdrawHelper(bob, bobDestination);

      assert.equal(
        Number(await web3.eth.getBalance(bobDestination)),
        0,
        "Bob took alice's money."
      );

      await withdrawHelper(alice, aliceDestination);
      assert.equal(
        Number(await web3.eth.getBalance(aliceDestination)),
        bobBal,
        "Alice's balance resolved incorrectly after her withdrawal."
      );

      assert.equal(
        await web3.eth.getBalance(simpleAdj.address),
        0,
        "SimpleAdjudicator wasn't emptied"
      );
    });
  });

  describe('events', async () => {
    it.skip('emits fundsReceived upon contract creation', async () => {
      CountingStateArtifact.bytecode = (linker.linkBytecode(CountingStateArtifact.bytecode, { "State": StateLibArtifact.networks[networkId].address }));

      CountingGameArtifact.bytecode = (linker.linkBytecode(CountingGameArtifact.bytecode, { "CountingState": CountingStateArtifact.networks[networkId].address}));
      const countingGameContract = await ContractFactory.fromSolidity(CountingGameArtifact, wallet).attach(CountingGameArtifact.networks[networkId].address);

      simpleAdj = await ContractFactory.fromSolidity(SimpleAdjudicatorArtifact, wallet).deploy(channel.id, 5);

      channel = new Channel(countingGameContract.address, 0, [alice.address, bob.address]);

      simpleAdj = await ContractFactory.fromSolidity(SimpleAdjudicatorArtifact, wallet).deploy(channel.id, 5);

      let result = await truffleAssert.createTransactionResult(simpleAdj, simpleAdj.transactionHash);

      truffleAssert.eventEmitted(result, 'FundsReceived', (event) => {
        return (
          event.adjudicatorBalance.eq(new BN(0))
        );
      });
    });

    it('emits fundsReceived upon being sent funds', async () => {
      const address = ACCOUNTS[9];
      await simpleAdj.sendTransaction({
        from: address,
        value: 50
      });
      let result = await simpleAdj.sendTransaction({
        from: address,
        value: 100
      });

      truffleAssert.eventEmitted(result, 'FundsReceived', (event) => {
        return (
          event.adjudicatorBalance.eq(new BN(150)) &&
          event.sender === address &&
          event.amountReceived.eq(new BN(100))
        );
      });
    })
  });
});